package org.example.sample4;

import java.util.ArrayList;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class SumAllMain {

    public static void main(String[] args) {

        ArrayList<SumRange_Runnable> runnablesList = new ArrayList<>();

        // sum the values from 1 to 30, by splitting work into three tasks.
        runnablesList.add(new SumRange_Runnable(1, 10));
        runnablesList.add(new SumRange_Runnable(11, 20));
        runnablesList.add(new SumRange_Runnable(21, 30));

        final int NUMBER_OF_THREADS_IN_POOL = 2;    // number of threads in the thread pool.
        // Creating threads is 'expensive', so it makes sense to have a certain number
        // of thread objects created that can be reused to run a sequence of runnables.
        // The 'right' number of threads depends on the use-case.

        // Note that we have 2 threads in the thread pool, but we queue up 3 runnable tasks
        // to be executed. The first two will be executed on the two threads and the third
        // will be added to a queue.
        // When one runnable finishes, the thread that it was running on becomes available,
        // and the third runnable will be taken from the queue and
        // allocated to run on that thread.

        System.out.println("Assigning three Runnables to the Executor thread-pool.");
        ExecutorService executor = Executors.newFixedThreadPool(NUMBER_OF_THREADS_IN_POOL);

        for (int i = 0; i < runnablesList.size(); i++) {      // queue up all 3 runnables to be executed in thread pool
            executor.execute(runnablesList.get(i));
        }

        // At this point, the main thread is continuing here (executing main()), and the
        // executor is running two threads concurrently.

        // Next we need to make this main thread WAIT so that the executor threads can finish.

        executor.shutdown(); // request that the thread pool be shut down (not instantaneous)
        // At this point, no new runnables can be allocated to the executor queue and
        // all runnables assigned to the executor (those running in threads, and those in the queue)
        // will be completed.

        // Dependency.
        // The runnable tasks will be executing in the thread pool (one runnable per thread) in
        // parallel with this main() code in the main thread.
        // If we need to use the results generated by all the runnables (which we do),
        // we must pause the main thread until all the runnables have completed their work.
        // The code below uses awaitTermination() to achieve this.
        // This serves the same purpose of the thread.join() in the previous samples -
        // it stops the current (main) thread here until all queued executor runnable tasks
        // in the pool have terminated.
        // Once all have finished, the main thread can 'awaken' (continue on)  and the range 'sum'
        // results will be available in each of the runnable objects.
        // We can then retrieve them and add them all up.

        try {
            int count = 0;
            while (!executor.awaitTermination(100, TimeUnit.MILLISECONDS)) {
                // if all threads have not terminated in the last 100ms interval, then
                // print the time lapsed, and then wait again for another 100 ms.
                // This message will display only if it takes longer than 100ms for
                // the executor to complete its work.
                System.out.println("Waiting - time passes = " + (count * 100) +" milliseconds");
                count++;
            }
        } catch (InterruptedException ex) {
            System.out.println("Interrupted exception: " + ex);
        }

        System.out.println("Executor has been shutdown, and all runnables have finished their work....");
        System.out.println("Summing up the 'sum' values from the runnables....");
        int total = 0;
        int i=0;
        for (SumRange_Runnable runnable : runnablesList) {
            System.out.println("Sum from runnable in thread " + ++i +" = " + runnable.getSum() );
            total = total + runnable.getSum();
        }
        System.out.println("Grand total (Sum 1 to 30) = " + total);
    }
}
